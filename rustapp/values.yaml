replicaCount: 1
image:
  repository: texplode/rusttaskctwo
  pullPolicy: IfNotPresent
  tag: 9634230919
imagePullSecrets: []
nameOverride: rustapp
fullnameOverride: rustapp
serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ''
podAnnotations: {}
podLabels: {}
podSecurityContext: {}
securityContext: {}
service:
  type: ClusterIP
  port: 3500
ingress:
  enabled: false
  className: ''
  annotations: {}
  hosts:
    - host: rustdemo.t4cdigital.com
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
resources: {}
livenessProbe:
  httpGet:
    path: /health
    port: http
readinessProbe:
  httpGet:
    path: /health
    port: http
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
volumes: []
volumeMounts: []
nodeSelector: {}
tolerations: []
affinity: {}




1. Application built on rust - Devolopers build application
2. Build a docker compose lab for testing rust app in containers - Devops picks up the app and ran it in containers locally
3. Created pipeline to integrate rust app, test and build - Devops created a pipeline workflow with githubactions to test and build rust app with docker
4. Created infrastructure (kubernetes and components) using terraform - Devops/SRE can create infrastructure with terrform but in this an SRE did
5. Set up kubernetes installations (ingress, cloudflared, argocd and sonarqube) - Devops/SRE setup ingresses cloudflared argocd and sonarqube
6. Integrated trivy for image vulnerability check and sonarqube for code quality test - Devops/SRE/Dev (Dev to access sonarqube to check for code quality report)
7. Deployed rust app using a fully build pipeline - Devops have a full working pipeline